{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///do_external_connect.min.js","webpack:///webpack/bootstrap 9d019f3ec142bc181cdb","webpack:///./connection_optimization/do_external_connect.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","checkForConnectHandlerAndConnect","window","APP","connect","status","handler","errorCallback","error","console","warn","XMPPAttachInfo","hashParams","getConfigParamsFromUrl","searchParams","url","hasOwnProperty","config","externalConnectUrl","createConnectionExternally","roomName","getRoomName","token","jwt","connectionInfo","data"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,QACA,sBAAAG,gBAAAC,IACAD,UAAAH,OACA,CACA,GAAAK,GAAAL,GACA,QAAAM,KAAAD,IAAA,gBAAAJ,iBAAAF,GAAAO,GAAAD,EAAAC,KAECC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,UAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,UAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAGAR,EAAA,KDgBM,SAASP,EAAQD,GAEtB,YEQD,SAASiB,KACLC,OAAOC,KAC8B,UAA9BD,OAAOC,IAAIC,QAAQC,QACnBH,OAAOC,IAAIC,QAAQE,UAS9B,QAASC,GAAcC,GAEnBA,GAASC,QAAQC,KAAKF,GAItBN,OAAOS,gBACHN,OAAQ,SAEZJ,IApEJ,GAAMW,GAAaC,uBAAuB,WACpCC,EAAeD,uBAAuB,aAGxCE,EACEH,EAAWI,eAAe,6BACtBJ,EAAW,6BACXK,OAAOC,kBAEjB,IAAIH,GAAOb,OAAOiB,2BAA4B,CAC1C,GAAMC,GAAWC,aAEjB,IAAID,EAAU,CACVL,YAAgBK,CAEhB,IAAME,GACAV,EAAW,iBAAmBK,OAAOK,OAASR,EAAaS,GAE7DD,KACAP,aAAiBO,GAGrBH,2BACIJ,EACA,SAAAS,GAGItB,OAAOS,gBACHN,OAAQ,UACRoB,KAAMD,GAEVvB,KAEJM,OAEJA,SAGJA","file":"do_external_connect.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/libs/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* global config,\n\t          createConnectionExternally,\n\t          getConfigParamsFromUrl,\n\t          getRoomName */\n\t\n\t/**\n\t * Implements external connect using createConnectionExternally function defined\n\t * in external_connect.js for Jitsi Meet. Parses the room name and token from\n\t * the URL and executes createConnectionExternally.\n\t *\n\t * NOTE: If you are using lib-jitsi-meet without Jitsi Meet you should use this\n\t * file as reference only because the implementation is Jitsi Meet-specific.\n\t *\n\t * NOTE: For optimal results this file should be included right after\n\t * external_connect.js.\n\t */\n\t\n\tvar hashParams = getConfigParamsFromUrl('hash', true);\n\tvar searchParams = getConfigParamsFromUrl('search', true);\n\t\n\t// URL params have higher proirity than config params.\n\tvar url = hashParams.hasOwnProperty('config.externalConnectUrl') ? hashParams['config.externalConnectUrl'] : config.externalConnectUrl;\n\t\n\tif (url && window.createConnectionExternally) {\n\t    var roomName = getRoomName();\n\t\n\t    if (roomName) {\n\t        url += '?room=' + roomName;\n\t\n\t        var token = hashParams['config.token'] || config.token || searchParams.jwt;\n\t\n\t        if (token) {\n\t            url += '&token=' + token;\n\t        }\n\t\n\t        createConnectionExternally(url, function (connectionInfo) {\n\t            // Sets that global variable to be used later by connect method\n\t            // in connection.js.\n\t            window.XMPPAttachInfo = {\n\t                status: 'success',\n\t                data: connectionInfo\n\t            };\n\t            checkForConnectHandlerAndConnect();\n\t        }, errorCallback);\n\t    } else {\n\t        errorCallback();\n\t    }\n\t} else {\n\t    errorCallback();\n\t}\n\t\n\t/**\n\t * Check if connect from connection.js was executed and executes the handler\n\t * that is going to finish the connect work.\n\t *\n\t * @returns {void}\n\t */\n\tfunction checkForConnectHandlerAndConnect() {\n\t    window.APP && window.APP.connect.status === 'ready' && window.APP.connect.handler();\n\t}\n\t\n\t/**\n\t * Implements a callback to be invoked if anything goes wrong.\n\t *\n\t * @param {Error} error - The specifics of what went wrong.\n\t * @returns {void}\n\t */\n\tfunction errorCallback(error) {\n\t    // The value of error is undefined if external connect is disabled.\n\t    error && console.warn(error);\n\t\n\t    // Sets that global variable to be used later by connect method in\n\t    // connection.js.\n\t    window.XMPPAttachInfo = {\n\t        status: 'error'\n\t    };\n\t    checkForConnectHandlerAndConnect();\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// do_external_connect.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9d019f3ec142bc181cdb","/* global config,\n          createConnectionExternally,\n          getConfigParamsFromUrl,\n          getRoomName */\n\n/**\n * Implements external connect using createConnectionExternally function defined\n * in external_connect.js for Jitsi Meet. Parses the room name and token from\n * the URL and executes createConnectionExternally.\n *\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet you should use this\n * file as reference only because the implementation is Jitsi Meet-specific.\n *\n * NOTE: For optimal results this file should be included right after\n * external_connect.js.\n */\n\nconst hashParams = getConfigParamsFromUrl('hash', true);\nconst searchParams = getConfigParamsFromUrl('search', true);\n\n// URL params have higher proirity than config params.\nlet url\n    = hashParams.hasOwnProperty('config.externalConnectUrl')\n        ? hashParams['config.externalConnectUrl']\n        : config.externalConnectUrl;\n\nif (url && window.createConnectionExternally) {\n    const roomName = getRoomName();\n\n    if (roomName) {\n        url += `?room=${roomName}`;\n\n        const token\n            = hashParams['config.token'] || config.token || searchParams.jwt;\n\n        if (token) {\n            url += `&token=${token}`;\n        }\n\n        createConnectionExternally(\n            url,\n            connectionInfo => {\n                // Sets that global variable to be used later by connect method\n                // in connection.js.\n                window.XMPPAttachInfo = {\n                    status: 'success',\n                    data: connectionInfo\n                };\n                checkForConnectHandlerAndConnect();\n            },\n            errorCallback);\n    } else {\n        errorCallback();\n    }\n} else {\n    errorCallback();\n}\n\n/**\n * Check if connect from connection.js was executed and executes the handler\n * that is going to finish the connect work.\n *\n * @returns {void}\n */\nfunction checkForConnectHandlerAndConnect() {\n    window.APP\n        && window.APP.connect.status === 'ready'\n        && window.APP.connect.handler();\n}\n\n/**\n * Implements a callback to be invoked if anything goes wrong.\n *\n * @param {Error} error - The specifics of what went wrong.\n * @returns {void}\n */\nfunction errorCallback(error) {\n    // The value of error is undefined if external connect is disabled.\n    error && console.warn(error);\n\n    // Sets that global variable to be used later by connect method in\n    // connection.js.\n    window.XMPPAttachInfo = {\n        status: 'error'\n    };\n    checkForConnectHandlerAndConnect();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./connection_optimization/do_external_connect.js"],"sourceRoot":""}